--

Use webkit filter blur and opacity to blue out the whole web page when we do some things that make that useful.

This effect is SO useful.

It really aids with cognitive load. It should be standard!

It's gonna change everything. It also helps us see patterns. 

Maybe we can use it with masking, too. 

--

BUILD BUILD APP VIEW, SPREADSHEET. BOOM. FUCK YEAH.



--
DONE

Templating should be in attributes only.

Templating and data binding are unified.

--

I've got some of the way. 

Clean up all the code before moving forward.

Total refactor. And clean.

--

Implement a way to set debug messages over a number of levels. Like an 

emit(error_level, msg) function.

--
Remove the use of scripts. Instead, load the code into an element, "script-src", 
and it is an immediately executed function expression, which we then obtain the contexts of and eval to get a return value like 
{ setup : function ..., attr_changed : function ... , ... }

So we can then not clutter the global scope. And we can give each of these functions a property on some global object, instead of on the global window object. We also don't have to worry about coupling the function names to the tag names, as this is done at eval time. Boom.

Additionally, we can define any global functions we might need by simply adding extra functions in there. Like 
"position" or some such. Because position is not one of the standard functions, it is added, unprefixed, to the global scope. I think this way of modularising code, and loading it when we like using eval of IIFE's and then binding the functions returned from the IIFE evaluation to properties of some globally accessible object is desirable. This just reduces some boilerplate and coupling. 

--

Write a few more global functions that can be used within the other functions, such as other global functions and standard functions such as setup and attr_changed and more that perform helping tasks, so we refactor the code and modularise it to increase re-use, efficiency and maintainability.


-- 

Implement a conditional such that

<op-if condition="float-panel#target[active]">
	<op-then>
		<!-- 
			remove active 
		!-->	
	</op-then>
	<op-else>
		<!-- 
			add active
		!-->
	</op-else>
</op-if>

--

Implement a way to drag and resize some float panels.

Drag region indicated with a attribute.

Draggable indicated with an attribute.

Resizable indicated with an attribute.

--
Implement the "trifecta" attribute for do-tool which acts as a visual plural
Perhaps rename the attribute to plural
In any case we stack 3 1/3 size icons atop each other in a triangular configuration
the same as the Chinese say "savor" with three mouth characters and forest with three trees. 
--
=DONE=
A button style with host context parent hover make visibility visibile
With attribute visibile

--

So what ops have is a code file that defines a few things
When the op is defined any code in that code file is executed. So that's essentially
the "on definition handler"

Then when an op is instantiated it executes a setup_{op code name} function

Then when an op has an attribute changed it executes a attribute_changed_{op code name} function

None of these functions have to be defined. We retry a few times. 

--

Let's have custom tags to inject a script in a webview. So we can declaratively say

<inject-script src={url} destination={webview selector}></inject-script>

And maybe even tags to declare webview event projects

<project-event from={webview selector} data={data specifiers} local-name={local name to issue event with}></project-event>


And even declarative handling of such events

<handle-webview-event from={webview selector} event={event name} handler={handler function name}></handle-webview-event>

Awesome!


--

I want the app to look ok even if there is no css or javascript.

So we need to use H1, link, lists, list items, definition, summary, and other markup. 

-- 

We need to have a clear API with two sides

One side projects information from webview to application through either direct requests from the application side or triggered by pre-declared event observers on the webview side. 

We can specify in these declarative observers, what the event is, what any target is, if we want to throttle these (and therefore how many to wait before allowing one through, or a summary of all waited through, or how long to wait after the last one before allowing one through), and the information from the webview side we want to project through.

And it's not only events we can watch, but other things like modifications to the page and we can even check for the appearance of things such as the appearance of a "captcha challenge", these things effectively become their own custom events, the declarations of which can be bought and sold on the marketplace just like anything else.

Additionally we can specify declaratively a response to any event thus observed, and projected, such as a response to a modal dialog box, or a response to a "captcha challenge" such as sending it for resolution to one of the many captcha resolving services. 

Now, the other side of the API necessitates even less description. It is simply a way to project various user intents from the application side into the webview. 

Finally, we say that the above two-sided interface is the technical core of the product, and the user interaction core of the product is the various workflows for the creation of these declarative reqests, responses and observers which are utilised by this interface to drive the cross-border through-the-interface interactions between application and webview.

For an alternative discussion see the voice memo file titled, Complete Clarity of App Technicals and User Interaction


--

We can create a custom element that derives from the webview

Cool

And then a custom element for a tab that inclues this custom webview element.

Tabs, webview interface.

--


